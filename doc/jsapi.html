<!DOCTYPE html><html><head><meta charset=utf-8 /><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1" /><meta name=viewport content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0" /><link href=/mirrorui/mirrorui.css rel=stylesheet /><title>常用jsapi | Mirror Space</title><style>.page{display:grid;grid-template-columns:210px auto;background-color:#fffff0}.menu-box{position:sticky;top:0;width:94%;max-height:100vh;overflow-x:hidden;overflow-y:auto}.apiarea{margin-bottom:50px}.apiarea h2:first-child{background-color:var(--grayback)}.code{color:#ff4500}</style></head><body><div class=page><div class=menu-box><nav class=sidemenu-box id=main_menubox><ul class=sidemenu-group id=domopbox><li><span class=sidemenu-label>Dom操作<i class=sidemenu-arrdown></i></span></li></ul></nav></div><div class="content pd-15"><div class=msgpanel><h3>常用jsapi整理</h3><p>参考文档: <a href="https://developer.  mozilla.org/zh-CN/docs/Web/API/Element" target=_blank>jsdom操作MDN文档</a></p><p>目的: 为了查找方便而编辑整理的API文档,可以直接复制代码使用.</p><p>测试: 编辑文档时,做了基本的测试,结果符合文档描述.但是没有做复杂情况下的测试.测试浏览器是谷歌 79.0.3945.88 版本以上.</p><p>包装: js的api名字很多比较长,写起来比较啰嗦.用比较短的函数名包装一遍,可以明显减少打字量.也可以减少源码长度.</p></div><hr class=line /><div id=createElement class=apiarea><h2>createElement()</h2><p>生成一个DOM元素,参数是html元素的名字.下面生成一个DIV.</p><p class=code>let divdom = document.createElement('div');</p><p>代码有些长,可以封装成一个方法如下</p>
        <pre class=code>
function newDom(name)
{
  return document.createElement(name);
}
</pre></div><div id=appendChild class=apiarea><h2>appendChild()</h2><p>方法将一个节点添加到指定父节点的子节点列表末尾.</p><p class=code>var child = node.appendChild(child);</p><p>appendChild 方法会把要插入的这个节点引用作为返回值返回.</p><p>如果被插入的节点已经存在于当前文档的文档树中,则那个节点会首先从原先的位置移除,然后再插入到新的位置</p><p>如果你需要保留这个子节点在原先位置的显示,则你需要先用Node.cloneNode方法复制出一个节点的副本,然后在插入到新位置</p><p>这个方法只能将某个子节点插入到同一个文档的其他位置,如果你想跨文档插入,你需要先调用document.importNode方法</p></div><div id=append class=apiarea><h2>append()</h2><p class=code>void ParentNode.append((Node or DOMString)... nodes);</p><p>一组要插入的 Node 或 DOMString 对象</p><p>与 Node.appendChild() 的差异:</p><ul class="list square"><li>ParentNode.append()允许追加 DOMString 对象,而 Node.appendChild() 只接受 Node 对象</li><li>ParentNode.append() 没有返回值,而 Node.appendChild() 返回追加的 Node 对象</li><li>ParentNode.append() 可以追加多个节点和字符串,而 Node.appendChild() 只能追加一个节点</li></ul></div><div id=removeChild class=apiarea><h2>removeChild()</h2><p>删除元素.父元素删除子元素.例如一个div元素,要删除自己的子元素p,那么如下</p><p class=code>div.removeChild(p)</p><p>如果有p对象,没有父级div对象,要删除p,可以如下</p><p class=code>p.parentNode.removeChild(p);</p></div><div id=insertAdjacentElement class=apiarea><h2>insertAdjacentElement()</h2><p>插入元素.例如一个p元素,要将自己插入到另一个div元素的"前"~"后"~"内前"~"内后",那么如下</p><p class=code>div.insertAdjacentElement('beforebegin',p); // p在div的前面</p><p class=code>div.insertAdjacentElement('afterbegin',p); // p在div内部的第一个子节点之前</p><p class=code>div.insertAdjacentElement('beforeend',p); // p在div内部的最后一个子节点之后</p><p class=code>div.insertAdjacentElement('afterend',p); // p在div的后面</p><p class=text-danger>注意: 当节点处于DOM树中而且有一个父元素的时候 beforebegin 和 afterend操作才能起作用</p><p class=text-danger>这句话的意思是,p如果要插入到div的前面或者后面,前提是div必须要有一个父元素.</p><p>如果是新生成的div,没有父级,但是要用beforebegin 和 afterend操作怎么办?可以建立文档片段DocumentFragment,将div放入其中就可以用了.</p></div><div id=hasAttribute class=apiarea><h2>hasAttribute()</h2><p>返回一个布尔值,指示该元素是否包含有指定的属性</p><p class=code>let result = element.hasAttribute(attName);</p><p>result 为返回的布尔值true 或 false</p><p>attName 是一个字符串,表示属性的名称</p></div><div id=getAttribute class=apiarea><h2>getAttribute()</h2><p>返回元素上一个指定的属性值.如果指定的属性不存在,则返回null或"".</p><p>返回值attribute是一个包含attributeName 属性值的字符串.</p><p class=code>let attribute = element.getAttribute(attributeName);</p><p>例如取val的值 &lt;div val="time">&lt;/div></p><p class=code>let timeval=div.getAttribute['val']; // time</p></div><div id=classList class=apiarea><h2>classList</h2><p>只读属性,返回一个元素的类属性的实时 DOMTokenList 集合</p><p class=code>const elementClasses = elementNodeReference.classList;</p><p>如果类属性未设置或为空,那么 elementClasses.length 返回 0</p><h4>classList有下列常用方法</h4><h4 class=code>add(...string[])</h4><p>添加指定的样式类名.如果这些类已经存在于元素的属性中,那么它们将被忽略</p><p>参数是不定个数的,用逗号隔开</p><br /><h4 class=code>remove(...string[])</h4><p>删除指定的类值.注意:即使删除不存在的类值也不会导致抛出异常</p><br /><h4 class=code>toggle( string [, force] )</h4><p>当只有一个参数时: 切换类值;也就是说,即如果类值存在,则删除它并返回 false,如果不存在,则添加它并返回 true</p><p>当存在第二个参数时: 若第二个参数的执行结果为 true,则添加指定的类值,若执行结果为 false,则删除它</p><br /><h4 class=code>contains( string )</h4><p>检查元素的类 class 属性中是否存在指定的类值.返回值为 true | false</p><br /><h4 class=code>replace( oldClass, newClass )</h4><p>用一个新类值替换已有的类值.测试时发现,成功替换返回true,失败返回false</p></div><div id=setAttribute class=apiarea><h2>setAttribute</h2><p class=code>element.setAttribute(name, value);</p><p>设置指定元素上的某个属性值.如果属性已经存在,则更新该值;否则,使用指定的名称和值添加一个新的属性</p><p class=code>div.setAttribute('val', 100); // div上设置val,值100</p></div><div id=removeAttribute class=apiarea><h2>removeAttribute</h2><p class=code>element.removeAttribute(attrName);</p><p>元素方法 removeAttribute() 从指定的元素中删除一个属性.如果属性不存在,不会报出异常.</p><p>若要彻底移除一个属性的效果,应当使用 removeAttribute(),而不是使用 setAttribute() 将属性值设置为 null.对于许多属性,如果仅将其值设为 null,这不会造达成和预期一样的效果</p></div><div id=createDocumentFragment class=apiarea><h2>createDocumentFragment()</h2><p class=code>const fragment = document.createDocumentFragment();</p><p>生成一个dom片段,表示一个没有父级文件的最小文档对象.</p><p>DocumentFragment 不是真实 DOM 树的一部分,它的变化不会触发 DOM 树的重新渲染,且不会导致性能等问题</p><p>这个方法非常有用,当需要一个html模板时(例如做js组件),可以用js生成html,存放在DocumentFragment中.</p><p>对DocumentFragment中的模板进行dom操作,不会影响到当前页面,需要将模板显示在当前页面中时,只需要appendChild(DocumentFragment).</p><p></p><p class=text-danger>片段被添加(append)或被插入(inserted)的是片段的所有子节点, 而非片段本身.</p></div><div id=querySelector class=apiarea><h2>querySelector()</h2><p class=code>element = document.querySelector(selectors);</p><p class=code>element = baseElement.querySelector(selectors);</p><p class=code>element = documentfragment.querySelector(selectors);</p><p>返回一个 Element 表示与指定的选择器组匹配的第一个元素.如果没有匹配,返回null</p><p>selectors是一个选择器,例如 "#name"(id选择器) ".name"(类选择器) "[prop=val]属性选择器"</p><p class=text-danger>selectors参数必须是浏览器支持的选择器,否则会异常.</p><p>不仅在document对象上可以使用,也可以在Element对象上使用,还可以在DocumentFragment对象上使用</p><p><b>误区</b>: 可能会认为在document上调用,是从文档跟元素开始查找.而在baseElement上调用,是从baseElement开始查找.其实不是这样的.</p><p class=text-danger>选择器首先会应用到整个文档,而不是baseElement,来创建一个可能有匹配元素的初始列表.然后从结果元素中检查它们是否是baseElement的后代元素.如果是,那么第一个匹配的元素将会被querySelector()方法返回</p><p>做一个测试,以id="box"的div为基础元素,匹配第二个a元素</p>
        <pre class=code>
&lt;div id="box">
    &lt;a>1&lt;/a>
    &lt;div>&lt;a>第二个a元素&lt;/a>&lt;/div>
&lt;/div>
// 测试代码和结果
var baseElement = document.querySelector("#box");
let a2 = baseElement.querySelector("div div a"); // &lt;a>第二个a元素&lt;/a>
let a1 = baseElement.querySelector("div a");     // &lt;a>1&lt;/a>
</pre></div><div id=querySelectorAll class=apiarea><h2>querySelectorAll()</h2><p class=code>elementList = document.querySelectorAll(selectors);</p><p class=code>elementList = parentNode.querySelectorAll(selectors);</p><p class=code>elementList = documentfragment.querySelectorAll(selectors);</p><p>返回一个 NodeList 表示元素的列表,把当前的元素作为根与指定的选择器组相匹配.</p><p>做一个测试,以id="box"的div为当前元素,匹配所有的div元素.结果找到一个div</p><p class=text-danger>这说明查找是以当前元素(调用对象)为根(匹配起点)的,并且不包含当前元素.</p>
        <pre class=code>
&lt;div id="box">
    &lt;a>1&lt;/a>
    &lt;div>&lt;a>第二个a元素&lt;/a>&lt;/div>
&lt;/div>
// 测试代码和结果
var container = document.querySelector("#box");
let matches = container.querySelector("div"); // NodeList[div] &lt;div>&lt;a>第二个a元素&lt;/a>&lt;/div>
</pre><br /><p><b>注意</b>:不要在选择器上使用伪类.否则结果总是空的NodeList[].</p><p class=text-danger>document.querySelector("div::first"); // 结果为空NodeList[].</p><h4>一些例子</h4><p>匹配有menuitem样式类的span元素</p><p class=code>div.querySelectorAll("span.menuitem");</p><p>匹配有menuitem和active样式类的span元素</p><p class=code>div.querySelectorAll("span.menuitem.active");</p><p>匹配有checked属性(选中的)的input元素.</p><p class=code>div.querySelectorAll("input[checked]");</p><p>匹配val属性值为30的span元素.注意,'30'加了引号,否则报异常:选择器不合法.</p><p class=code>div.querySelectorAll("span[val='30']");</p><p>匹配val属性值为30,和有menuitem样式类的span元素.</p><p class=code>div.querySelectorAll("span[val='30'],span.menuitem");</p></div><div id=insertBefore class=apiarea><h2>insertBefore()</h2><p class=code>var insertedNode = parentNode.insertBefore(newNode, referenceNode);</p><ul class="list square"><li>insertedNode 已经经过插入newNode的新的节点</li><li>parentNode 新插入节点的父节点</li><li>newNode 用于插入的节点</li><li>referenceNode newNode 将要插在这个节点之前</li></ul><p>如果 referenceNode 为 null 则 newNode 将被插入到子节点的末尾.referenceNode 引用节点不是可选参数——你必须显式传入一个 Node 或者 null</p><p>函数返回被插入过的子节点;当 newNode 是 DocumentFragment 时,返回空 DocumentFragment</p><p>例: 把span插入到div的第一个子元素前面.返回值result就是span元素</p><p class=code>let result = div.insertBefore(span, div.firstChild);</p></div></div></div><template><div id=api名字 class=apiarea><h2>api名字,方法有括号,属性没有括号</h2><p class=code>调用代码</p><p>调用代码说明...</p><p>...</p><p>其它测试说明</p></div></template><script src=/mirrorui/mirrorui.js></script><script>(()=>{let n={domopbox:["append","appendChild","classList","createElement","createDocumentFragment","getAttribute","hasAttribute","insertAdjacentElement","insertBefore","querySelector","querySelectorAll","removeChild","removeAttribute","setAttribute"]};for(let t in n){let r=document.createDocumentFragment(),i=n[t];for(let n=0;n<i.length;n++){let u=document.createElement("li"),t=document.createElement("a");t.classList.add("sidemenu-item");t.href="#"+i[n];t.innerText=i[n];u.appendChild(t);r.appendChild(u)}document.getElementById(t).appendChild(r)}})();sidemenu("main_menubox")</script></body></html>