<!DOCTYPE html><html lang=en><head><meta charset=utf-8 /><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1" /><meta name=viewport content="width=device-width,initial-scale=1.0,user-scalable=no" /><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png /><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png /><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png /><link rel=manifest href=/site.webmanifest /><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5 /><meta name=msapplication-TileColor content=#da532c /><meta name=theme-color content=#ffffff /><title>组合数学 | Mirror Space</title><link href=/mirrorui/mirrorui.css rel=stylesheet /><link href=/asset/css/blog.css rel=stylesheet /></head><body><div class=layout><div class=layout-part1><a class="mainmenu-onoff d-block d-md-none" onclick=mainmenuonoff()>Ω</a><div id=mainmenubox class="mainmenu d-none d-md-block"><div class=logobox> <img src=/asset/img/logo.jpg class=logoimg /></div><h3 class=pd-5>Mirror Space</h3><hr class=line /><a class=mainmenu-link href=/index.html>Home</a> <a class=mainmenu-link href=/about.html>About</a> <a class=mainmenu-link href=/projectinfo.html>Info</a><div class=theme id=themebox> <a class=mainmenu-btn onclick=changetheme(1)>白天sun</a> <a class=mainmenu-btn onclick=changetheme(2)>夜晚moon</a><br /> <a class=mainmenu-btn onclick=changefontsize(14)>A</a> <a class=mainmenu-btn onclick=changefontsize(16)>AA</a> <a class=mainmenu-btn onclick=changefontsize(20)>AAA</a></div></div><script src=/asset/js/mainmenu.js></script></div><div class=layout-part2><p>组合数学(原书第5版) 美 Richard Brualdi</p><div id=menubox class="grids-2 grids-sm-5"></div><h3>什么是组合数学</h3><p>数学归纳法</p><p>b-ominoe b 格牌 覆盖棋盘的(条形牌) (3页)</p><h5 id=m1>幻方</h5><p>一个 n x n 矩阵,其行~列~对角线上元素和都相等.和叫幻和.</p>
<pre class=bg-gray>
    8 1 6
    3 5 7
    4 9 2
    // 这个3阶幻方的幻和是15
    n 阶幻方的幻和公式 s = n * (n^2 + 1) / 2

</pre><p>la Loubere 构造幻方的方法.可以造出 n 为奇数时的幻方. (5页)</p><h5 id=m2>36军官问题</h5><p>拉丁方</p><p>拉丁方是一个 n x n 矩阵,其元素特点是每一行每一列都是 (1,2,..,n) 的一种排列,且没有两行或者两列出现相同的排列.</p><p>或者是这样, (1,2,..,n)里的元素,在拉丁方的每一行每一列都出现一次.</p>
<pre class=bg-gray>
    // 3阶拉丁方 每一行每一列都有 (1,2,3) 这3个数
    1 2 3
    3 1 2
    2 3 1

    // 又一个3阶拉丁方
    1 3 2
    3 2 1
    2 1 3

    // 这个不是拉丁方,第2列没有3,第3列没有2
    1 2 3
    3 2 1
    2 1 3

</pre><p>正交拉丁方</p><p>如果有两个 n x n 的拉丁方矩阵 A B ,它们的元素按相应位置组成一个新元素c1(a1,b1),得到一个新的 n x n 矩阵 C.它的每个元素都互不相同.那么,A B是互相正交的拉丁方.</p>
<pre class=bg-gray>
    // 3阶拉丁方 A
    1 2 3
    3 1 2
    2 3 1

    // 3阶拉丁方 B
    1 3 2
    3 2 1
    2 1 3
 
    // 组合 A B , 其元素都是互不相同的
    (1,1) (2,3) (3,2)
    (3,3) (1,2) (2,1)
    (2,2) (3,1) (1,3)

</pre><p>2阶拉丁方例子,也就是 A B 这两种情况了.</p>
<pre class=bg-gray>
    // A
    1 2
    2 1

    // B
    2 1
    1 2

    // 组合 A B ,可见元素有相同的,2阶拉丁方不存在正交的.
    (1,2) (2,1)
    (2,1) (1,2)

</pre><h5>相互重叠的圆</h5><p>每个圆之间都相交,可以划分出多少个区域? 两个圆相交(不是相切)会有2个交点.</p><canvas id=canvas1></canvas><h3>二 排列与组合</h3><h5 id=m3>加法原理 (16页)</h5><p>书上的定义没有看懂,这是百科词条:</p><p>加法原理是分类计数原理,常用于排列组合中,具体是指:做一件事情,完成它有n类方式,第一类方式有M1种方法,第二类方式有M2种方法,……,</p><p>第n类方式有Mn种方法,那么完成这件事情共有M1+M2+……+Mn种方法.</p><p>例如,从上海到三亚.交通工具有飞机,船,火车3种,飞机有3班次,火车有2班次,船有1班次,那么上海到三亚的办法有3 + 2 + 1 = 6种.</p><h5>乘法原理</h5><p>百科词条:做一件事,完成它需要分成 n 个步骤,做第一步有 m1 种不同方法,做第二步有 m2 种不同方法,……,做第 n 步有 mn 种不同方法,那么完成这件事共有 m1 * m2 *...* mn 种不同的方法.</p><p>联系: 加法原理和乘法原理是两个基本原理,它们的区别在于一个与分类有关,另一个与分步有关.运用以上两个原理的关键在于分类要恰当,分步要合理.分类必须包括所有情况,又不要交错在一起产生重复,要依据同一标准划分;而分步则应使各步依次完成,保证整个事件得到完成,不得多余~重复,也不得缺少某一步骤.</p><h5>减法原理 (18页)</h5><h5>除法原理</h5><p>令 S 是一个有限集合,把它划分成 k 个部分使得每一个部分的对象数目相同,于是,部分的数目 k = |S| / 部分中的对象数目个数</p><h5>有6个苹果,9个橘子,做成1个水果篮,至少有1个水果.有多少种做法?</h5><p>思路: 如果只要苹果(做法1),有6种,分别是1~6个苹果.如果只要橘子(做法2),有9种.如果都要(做法3),那么乘法原理有 6 X 9 = 54 种.所以一共有 9 + 6 + 54 = 69种.</p><p>从百科定义思考: 做水果篮是一个事件,完成这件事有3种做法,1种有6种方法,2种9种,3种要分两步骤做,分别是6种和9种方法所以6X9,最后加法原理累加3种做法的方法数.</p><h5>10000 ~ 99999 之间偶数个数 ?</h5><p>这两个数之间有 99999 - 10000 = 89999 + = 90000 个数,由于奇数偶数交替出现,所以偶数为 90000/2 = 45000 个.</p><p>用组合的思路,这是一个五位偶数,所以要求个位是偶数.那么从高位到低位写出这个数,分五部.第一步有 1~9 9个选择, 2,3,4 位都是 0~9 10个选择,</p><p>个位是 0 2 4 6 8 5个选择,那么根据乘法原理得到, 9 * 10 * 10 * 10 * 5 = 45000 .</p><p>仍然是偶数,加一个条件,5个数字都不相同.有多少个?</p><p>先选择个位,再从万位到十位.因为每个位不能重复,所以下个选择要剔除选上个选中的.</p><p>// 思路</p><p>这里有一个细节容易出错,先看第一种方法,个位选 0 ,那么万位到十位就是, 9 * 8 * 7 * 6 = 3024</p><p>第二种方法,个位选 2 ,那么其它位是, 8 * 8 * 7 * 6 = 2688 当个位选 4,6,8 时,也一样如此.</p><p>那么相当于使用了5种方法(或者2种方法,后4种一样)完成选偶数这件事,那么根据加法原理,一共有偶素: 3024 + 2688 * 4 =13776</p><p>这个细节在于,选0为个位时,万位有9种选法(1~9),而选2,4,6,8时,万位有8种选法.(1~9,除去2,4,6,8其中一个)</p><h5>这个例子说明,优先选择约束性最强的选择. (20页)</h5>
<pre class=bg-gray>
    // 判断一个数字每个位都不同
    string num = number.ToString();
    bool issame = false;
    for (int j = 0; j < num.Length; j++)
    {
        // 拿出一个数字, 从字符串数组末尾开始,如果找到其它位还有这个数,说明重复
        if(num.LastIndexOf(num[j])!=j)
        {
            issame = true;
            break;
        }
    }
    // 10进制最大的各个位不同的数
    9876543210
    // 1 - 10位自然数,每位数不同
    数位   个数    奇数     偶数 
    1      9       5       4
    2      81      40      41
    3      648     320     328
    4      4536    2240    2296
    5      27216   13440   13776
    6      136080  67200   68880
    7      544320  268800  275520
    8      1632960 806400  826560
    9      3265920 1612800 1653120
    10     126000  58320   67680

</pre><h5>1 1 1 3 8 这五个数可以生成多少五位数 ?</h5><p>先看 3,8 这两个数放到五位数的任何位上,有5 * 4 = 20 种方法.第一步,3或者8有5种位置,第二部,3或者8有4种位置,乘法原理.</p><p>还剩下3个位置,剩下的3个1无论怎么放,在3,8已经确定位置的情况下,不会影响数字.所以就是有20种五位数.</p><p>如果是 1 1 1 3 3 如何? 10种</p><p>上面两个问题用加法和乘法原理不容易解决,因为集合有重复的元素,先学习排列.这是一个多重集合的排列数. (20页)</p><h5>排列</h5><p>n个元素的集合,r数目的排列数公式:</p><p>P(n,r) = n!/(n-r)! <i>线性排列</i></p><p>例如P(1,2,3) 任取2个数排列, 3!/(3-2)! = 6 种</p><p>P(n,r) / r = n! / (r * (n-r)!) <i>循环排列</i></p><p>线性排列和循环排列的区别在于,循环排列没有开始和结束,而线性排列有第一个元素和最后一个元素.这会产生一个现象,如果循环排列指定一个元素为开始元素,</p><p>按一个方向循环,到这个元素的相邻元素循环一周,会得到一个线性排列.这个排列在指定不同开始元素时不同.也就是说,一个循环排列可以包含多个线性排列.</p><h5 id=m4>集合的组合</h5><p>n 个元素的集合 S ,拿出 r 个元素,这 r 个元素是 S 的子集(无序).有多少种拿法.</p><p>S{a,b,c} n = 3,r = 2 有3个子集 {a,b} {a,c} {b,c}</p><p>(n r) = n! / (r! * (n-r)!) (25页)</p><p>帕斯卡公式 (26页)</p><h5>多重集合排列 (28页)</h5><p>多重集合 (百科词条)</p><p>多重集或多重集合是数学中的一个概念,是集合概念的推广.在一个集合中,相同的元素只能出现一次,因此只能显示出有或无的属性.</p><p>在多重集之中,同一个元素可以出现多次.正式的多重集的概念大约出现在二十世纪七十年代.多重集的势的计算和一般集合的计算方法一样,</p><p>出现多次的元素则需要按出现的次数计算,不能只算一次.一个元素在多重集里出现的次数称为这个元素在多重集里面的重数(或重次~重复度).</p><p>例如 S {a,b,c,c,b,a} ,元素个数是6,元素种数是3</p><p>多重集合 S 的排列数公式.其中,n 是 S 的元素个数, k 是元素的种数,n1是元素1的个数,n2是元素2的个数,nk是元素k的个数.那么 S 的 n 排列数为:</p><p>n! / (n1!n2!...nk!)</p><p>使用这个公式可以解决之前提到的问题: 1 1 1 3 8 可以生成多少五位数?</p><p>这是 n = 5,k = 3 的多重集合,5位数正好就是 n 排列,使用公式 5!/(3!*1!*1!) = 20</p><p>这个公式的证明思路举上面这个例子说明: 5位数,现象成5个格子,每个格子放一种数,有3个1,那么需要3个格子,3,8各需要一个格子,此时相当于</p><p>用3个步骤实现了这个5位数,那么根据乘法原理可得总排列数为: P(5,3) * P((5-3),1) * P((5-3-1),1) 用公式表示</p><p>5!/(3!*(5-3)!) * (5-3)!/(1!*(5-3-1)!) * (5-3-1)!/(1!*(5-3-1-1)!)</p><p>前项分母与后项分子消去得: (5!/3!) * (1 / 1!) * 1/(1!* 0!) = n! / (n1! * n2!...nk!)</p><h5 id=m5>多重集合的组合 (32页)</h5><p>设 S 是有 k 种对象的多重集合,每种元素都有无限重复数,那么 S 的 r 组合个数: C(r+k-1 r)</p><p>8种面包,12个装一盒,有多少种装法?</p><p>如题,12个里面有8个种类,所以这是一个多重集合(长度为12).只是装法,不要考虑12个面包的排列,所以是一个多重集合组合问题.</p><p>即: 长度为12的集合(S),有8种对象(k),12的组合数(r).</p><p>根据上面的公式,组合数为 C(12+8-1 12) = C(19 12) = 19! / (12! * (19-12)!) = 50388</p><p>如何验证这个结果,假设8个种类就是数字[1~8],组成一个12位长度的数字,可以有50388个数字.</p><p>不考虑顺序,例如 111111222222 和 222222111111 和 112211221122 是一个类型,它们都由6个1,6个2组成.</p><p>111111222222 和 111122222222不是一类,因为后面那个数是4个1和8个2组成的.不属于一类组合,多重集合组合是顺序不同,但元素相同,个数也相同.</p><p>最笨的方法,所有的这些数都在一个范围内[111111111111 ~ 888888888888],排除含有0和9的数.如果是同种组合,那么数字的种类和每个种类的个数必然相同.</p><p>根据这一点判断,写成代码验证.由于12个数字是千亿级别太多了,所以计算机测试的是长度为10的情况,C(10+8-1 10) = 17!(10! * (17-10)!) = 19488</p><p>每次开启1000个线程,跑10亿次FOR,一共跑8次,每次花费10分钟.最后使用计算机显示找到了 19448 个组合.说明验证成功,公式没有问题!</p><h5>有限概率 (34页)</h5><h3>三 鸽巢原理</h3><h5>ramsey定理</h5><h3>四 生成排列和组合</h3><p>列出{1,2,3,..,n}的所有排列,计算机算法其实是个递归.算法由Johnson 和 Trotter发现 (53页)</p><p>{1,2,3,..,n}的所有排列,可以视为在{1,2,3,..,n-1}的所有排列的每个元素前后位置插入n.而{1,2,3,..,n-1}的排列,可以视为{1,2,3,..,n-2}的所有排列的每个位置插入n-1...</p><p>最后一直到{1}的排列,只有一种,而{1,2}的所有排列就是在{1}的排列的元素 1 前后插入 2,得到{1,2} {2,1}.所以这是递归.</p><p>注意: {1,2,3,..,n-1}排列插入n的位置的数目是 (n-1)+1 = n .也可以说,存在n种方法,把{1,2,3,..,n-1}的一个排列,变成{1,2,3,..,n}的一个排列.</p><h3>附录</h3><p>附录 (394页)</p><hr class=line /><script src=/jslib/cavlib.js></script><script>(()=>{var t,u;let f=["<b>第1章 什么是组合数学<\/b>","1.1 例子:棋盘的完美覆盖","1.2 例子:幻方","1.3 例子:四色问题","1.4 例子:36军官问题","1.5 例子:最短路径问题","1.6 例子:相互重叠的圆","1.7 例子:Nim游戏","1.8 练习题","<b>第2章 排列与组合<\/b>","2.1 四个基本的计数原理","2.2 集合的排列","2.3 集合的组合（子集）","2.4 多重集合的排列","2.5 多重集合的组合","2.6 有限概率","2.7 练习题","<b>第3章 鸽巢原理<\/b>","3.1 鸽巢原理:简单形式","3.2 鸽巢原理:加强版","3.3 Ramsey定理","3.4 练习题","<b>第4章 生成排列和组合<\/b>","4.1 生成排列","4.2 排列中的逆序","4.3 生成组合","4.4 生成r子集","4.5 偏序和等价关系","4.6 练习题","<b>第5章 二项式系数<\/b>","5.1 帕斯卡三角形","5.2 二项式定理","5.3 二项式系数的单峰性","5.4 多项式定理","5.5 牛顿二项式定理","5.6 再论偏序集","5.7 练习题","<b>第6章 容斥原理及应用<\/b>","6.1 容斥原理","6.2 带重复的组合","6.3 错位排列","6.4 带有禁止位置的排列","6.5 另一个禁止位置问题","6.6 莫比乌斯反演","6.7 练习题","<b>第7章 递推关系和生成函数<\/b>","7.1 若干数列","7.2 生成函数","7.3 指数生成函数","7.4 求解线性齐次递推关系","7.5 非齐次递推关系","7.6 一个几何例子","7.7 练习题","<b>第8章 特殊计数序列<\/b>","8.1 Catalan数","8.2 差分序列和Stirling数","8.3 分拆数","8.4 一个几何问题","8.5 格路径和Schroder数","8.6 练习题","<b>第9章 相异代表系<\/b>","9.1 问题表述","9.2 SDR的存在性","9.3 稳定婚姻","9.4 练习题","<b>第10章 组合设计<\/b>","10.1 模运算","10.2 区组设计","10.3 Steiner三元系","10.4 拉丁方","10.5 练习题","<b>第11章 图论导引<\/b>","11.1 基本性质","11.2 欧拉迹","11.3 哈密顿路径和哈密顿圈","11.4 二分多重图","11.5 树","11.6 Shannon开关游戏","11.7 再论树","11.8 练习题","<b>第12章 再论图论<\/b>","12.1 色数","12.2 平面和平面图","12.3 五色定理","12.4 独立数和团数","12.5 匹配数","12.6 连通性","12.7 练习题","<b>第13章 有向图和网络<\/b>","13.1 有向图","13.2 网络","13.3 回顾二分图匹配","13.4 练习题","<b>第14章 Polya计数<\/b>","14.1 置换群与对称群","14.2 Burnside定理","14.3 Polya计数公式","14.4 练习题"],i="",n=10,r=f.length,e=r/n;r%n>0&&(e+=1);let o=[0,0,"m1",0,"m2",0,0,0,0,0,"m3",0,"m4",0,"m5"];for(t=0;t<e;t++){if(t*n>=r)break;for(i+='<ul class="list mg-b-10">',u=0;u<n;u++){let e=t*n+u;if(e>=r)break;i+=o[e]?`<li><a href="#${o[e]}">${f[e]}</a></li>`:`<li>${f[e]}</li>`}i+="<\/ul>"}let s=document.querySelector("#menubox");s.innerHTML=i})()</script><script>function canva1(){let e=cavlib("canvas1").style(),i=e.ctx,r=[{x:75,y:75,r:60,c:"red"},{x:115,y:45,r:30,c:"green"},{x:125,y:100,r:45,c:"blue"},{x:170,y:80,r:65,c:"brown"}];for(var u=0,o=r.length;u<o;u++){let n=r[u];i.beginPath();i.arc(n.x,n.y,n.r,0,Math.PI*2);i.strokeStyle=n.c;i.stroke()}let f={x1:0,y1:0,x2:0,y2:0},n=r[0],t=r[1];f.x1=Math.sqrt((t.y*n.r*n.r-n.y*t.r*t.r)/(n.x*t.y-t.x*n.y));f.y1=Math.sqrt((t.x*n.r*n.r-n.x*t.r*t.r)/(n.y*t.x-n.x*t.y));console.log(f)}canva1()</script></div></div></body></html>