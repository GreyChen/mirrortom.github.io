<!DOCTYPE html><html lang=en><head><meta charset=utf-8 /><meta http-equiv=X-UA-Compatible content="IE=edge" /><meta name=viewport content="width=device-width,initial-scale=1.0" /><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png /><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png /><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png /><link rel=manifest href=/site.webmanifest /><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5 /><meta name=msapplication-TileColor content=#da532c /><meta name=theme-color content=#ffffff /><title>canvas动画| canvas-demo | Mirror Space</title><link href=/mirrorui/mirrorui.css rel=stylesheet /><style scoped>.layout{display:grid;grid-template-columns:210px auto;min-height:100vh}.layout-right{padding:30px}</style></head><body><div class=layout><div class=layout-left><style>.mainmenu{position:sticky;top:122px;text-align:center}.mainmenu a{color:var(--graybackse);text-decoration:none}.mainmenu a:hover,.mainmenu a.active{color:var(--fontcolor);text-decoration:underline}.logobox{width:144px;height:144px;overflow:hidden;border-radius:50%;margin:22px auto}.logoimg{margin-left:-56px;animation:circleRoate 6s infinite linear}@keyframes circleRoate{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}</style><div class=mainmenu><div class=logobox><img src=/asset/img/logo.jpg class=logoimg /></div><h3>Mirror Space</h3><hr class=line /><a href=/index.html><h4>Home</h4></a> <a href=/about.html><h4>About</h4></a> <a href=/projectinfo.html><h4>Info</h4></a></div></div><div class=layout-right><h2>动画场景</h2><h3>抬手动作</h3><p>人眼看到画布上会动的影像,本质上和看一张照片一样.假如对一个站立的人拍照,那么得到一张站立着的照片,这个人抬起左手后,再拍照,得到</p><p>其抬起左手的照片,再放下左手拍照,又得到一张站立着的照片.此时会得到三张照片,在电脑上轮播这三张照片,如果播放速度比较快,那给观看</p><p>照片的人感觉就是照片在动,是一个人站立然后抬起左手,然后又放下的动作.</p><h3>细节</h3><p>上述是三张照片,可以看到这个人抬左手的动作,如果想看清楚这个人抬起左手的细节,比如抬起时手心在哪,抬起的角度等等,那么有一个办法</p><p>就是增加照片数量.可以让这人将抬手动作做得很慢,每抬起一点距离就拍张照片,如此一来可能得到几十张照片.然后将这些照片轮播,此时观看</p><p>者感觉到这人的抬手动作比较生动能看到过程.</p><h3>摄像</h3><p>上面的办法要求这个人做慢的抬手动作,显然需要有一个变通的办法.就是这个人正常抬手,在拍照时增加频率.简单的说就是在这人抬手动作</p><p>过程中,快速的拍照,直到动作完成.那么这样就得到更多的照片.这个过程可叫做摄像,可以认为摄像机在摄像时,其实是在不停的拍照片</p><h3>帧</h3><p>摄像过程本质上是拍了很多照片,这些照片可以按某种格式组成一个文件,例如"抬手动画.mp4".那么其中一张照片叫做帧.</p><p>这里有个问题,摄像时频率多少合适.如果太高,那么得到的照片很多,文件很大,虽然动作更细腻但太高时人眼也感觉不出了.而太少的话,文件较小</p><p>但是动作跨度大,很生硬.显然过多过少都不合适.那么可以设定一个频率,是60.也就是说每秒钟拍摄60张照片比较适宜.</p><canvas id=canvas1></canvas><h2>window.requestAnimationFrame()</h2><p>浏览器用于动画的方法是window.requestAnimationFrame(callback); 参数是一个方法引用,此方法就是绘图方法.对应的还有window.cancelAnimationFrame()</p><p>前者调用动画函数,返回值是一个long整数,后者传入这个数可以取消动画.这两个方法是专门为动画而造的.</p><p>window.setInterval() 和 window.setTimeout() 两个方法也可做动画,但这两方法并不是因为动画而造的.它们是通用的方法,用于定时指行程序</p><p>文档参考 <a href=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame target=_blank>https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame</a></p><p>回调函数(callback)会被传入DOMHighResTimeStamp参数,DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数</p><p>被触发的时间.在同一个帧中的多个回调函数,它们每一个都会接受到一个相同的时间戳,即使在计算上一个回调函数的工作负载期间已经消耗了一些时间.</p><p>该时间戳是一个十进制数,单位毫秒,最小精度为1ms(1000μs).</p><h3>其它书签</h3><p>&lt;&lt;H5核心技术图形动画与游戏开发(David Geary)>> (237页)</p><p>动画</p><p>&lt;&lt;H5核心技术图形动画与游戏开发(David Geary)>> (248页)</p><p>帧速率的计算逻辑</p><p>&lt;&lt;H5核心技术图形动画与游戏开发(David Geary)>> (270页)</p><p>动画制作最佳指导原则</p><p>&lt;&lt;H5核心技术图形动画与游戏开发(David Geary)>> (273页)</p><p>精灵对象</p><p>&lt;&lt;H5核心技术图形动画与游戏开发(David Geary)>> (340页)</p><p>碰撞检测,分离轴定理</p><p>&lt;&lt;H5核心技术图形动画与游戏开发(David Geary)>> (344页)</p><p>确定投影轴</p><p>&lt;&lt;H5核心技术图形动画与游戏开发(David Geary)>> (362页)</p><p>最小平移量 MTV</p><h2>直线运动</h2><p>直线运动比较简单,模拟物体在画布上的直线运动,使用s=vt位移公式,求出每时刻位置,然后绘画出来.距离单位米和画布单位像素设定比例100px=1米</p><h3>匀速直线运动</h3><p>长方形物体匀速直线运动,物体长宽 1*0.3, 速度 0.2m/s , 中心点从画布0px位置开始,移动到300px位置,如此重复</p><p>关键计算是,由DOMHighResTimeStamp参数计算出每一帧的时间间隔,然后0.2m/s要换算成 0.2 * interval / 1000 ,timeStamp参数单位是</p><p>毫秒,然后再累加移动距离,得到当前X轴位置,绘画.下图每走一圈,速度加0.1,加到1再重置为0.2</p><canvas id=canvas2></canvas><h3>匀加速直线运动</h3><p>加速度: 0.2m/平方s</p><canvas id=canvas3></canvas><script>function test3(){let t=getCanvas2d("canvas3");t.font="16px serail";t.textBaseline="middle";t.textAlign="center";let n=newPlayer();n.x0=0;n.y0=70;n.x1=300;n.y1=70;n.aSpeed=20;let i=0,r=0,u=f=>{i+=f-r,r=f,t.clearRect(0,0,300,150),n.runAt(t,i),n.isEnd()&&(n.reset(),i=0),window.requestAnimationFrame(u)};window.requestAnimationFrame(u)}function test2(){let i=getCanvas2d("canvas2");i.font="16px serail";i.textBaseline="middle";i.textAlign="center";let n=newPlayer();n.x0=0;n.y0=70;n.x1=300;n.y1=70;n.speed=20;let r=0,f=0,t=new newPlayer;t.x0=0;t.y0=30;t.x1=300;t.y1=150;t.speed=45;let u=0,e=0,o=s=>{r+=s-f,f=s,u+=s-e,e=s,i.clearRect(0,0,300,150),n.runVt(i,r),t.runVt(i,u),n.isEnd()&&(n.reset(),n.speed+=10,n.speed>100&&(n.speed=20),r=0),t.isEnd()&&(t.reset(),u=0),window.requestAnimationFrame(o)};window.requestAnimationFrame(o)}function newPlayer(){let n={};return n.x=0,n.y=0,n.x0=0,n.y0=0,n.x1=0,n.y1=0,n.width=100,n.height=30,n.speed=0,n.aSpeed=0,n.scale=100,n.isEnd=()=>n.x>n.x1,n.reset=()=>{n.start=0},n.sVt=t=>n.speed*t/1e3,n.sAt=t=>{let i=t/1e3;return 1/2*n.aSpeed*i*i},n.currXY=t=>{let i=getPointDistA(n.x0,n.y0,n.x1,n.y1,t);n.x=i[0];n.y=i[1]},n.draw=t=>{t.beginPath(),t.fillStyle="black",t.fillRect(n.x-n.width/2,n.y-n.height/2,n.width,n.height),t.fillStyle="white"},n.runVt=(t,i)=>{let r=n.sVt(i);n.currXY(r);n.draw(t);t.fillText(n.speed/n.scale+"m/s",n.x,n.y)},n.runAt=(t,i)=>{let r=n.sAt(i);n.currXY(r);n.draw(t);t.fillText(n.aSpeed/n.scale+"m/s*s",n.x,n.y)},n}function getPointDistA(n,t,i,r,u){if(n===i){const i=t+(t>r?-u:u);return[n,i]}if(t===r){const r=n+(n>i?-u:u);return[r,t]}let f=(r-t)/(i-n),e=n+Math.sqrt(u*u/(1+f*f)),o=t+f*e;return[e,o]}function test1(){let n=getCanvas2d("canvas1");n.fillRect(250,0,50,150);n.fillStyle="red";let t=0,r=randInt(10,140),i=randInt(1,8),u=randInt(5,15),f=()=>{if(n.clearRect(0,0,250,150),n.beginPath(),n.arc(t,r,u,0,Math.PI*2),n.fill(),t+=i,t>randInt(250+i,300)){t=0;r=randInt(10,140);i=randInt(1,8);u=randInt(5,15);let f=randInt(0,256),e=randInt(0,256),o=randInt(0,256);n.fillStyle=`rgb(${f},${e},${o})`}window.requestAnimationFrame(f)};window.requestAnimationFrame(f)}function getCanvas2d(n){let t=document.querySelector("#"+n);t.style.display="block";t.style.margin="20px";t.style.backgroundColor="#f0f0f0";return t.getContext("2d")}function randInt(n,t){let i=Math.random()*(t-n);return Math.floor(i)+n}test1();test2();test3()</script></div></div></body></html>