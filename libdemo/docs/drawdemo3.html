<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <link href="/mirrorui/mirrorui.min.css" rel="stylesheet" />
  <title>canvas-demo</title>
</head>
<body><div class="mg-lr-15"><style>
  .clockbox {
    position: relative;
  }

  .canva-panle {
    position: absolute;
    left: 0;
    top: 0;
  }
</style>
<h1>时钟</h1>
<p>运行的时钟,分两层canvas,底层是刻度,不动的.上层是时分秒,动的.</p>
<p>时刻度12份,每份30度.分刻度60份,每份6度,秒刻度60份,每份6度</p>
<h2>动画步骤</h2>
<p>对于秒针,每过一秒,走6度.</p>
<p>对于分针,每过一分,走6度.</p>
<p>对于时针,每过12分钟,走6度.</p>
<p>每帧会获取当前JS时间,取出时分秒,然后计算时钟针的所在位置</p>
<p>假如获取的时间是9点12分20秒.</p>
<h4>时针</h4>
<p>那么,时针位置是9*30度,(12点为起点),将画布旋转 9 * Math.Pi / 6.然后竖直画时针线.(0,0)(0,len)</p>
<p>时针的位置和分有关系,9点12分时,时针不能只是正对着9点,而需要体现过了12分这段位置</p>
<p>所以,旋转 9 * Math.Pi / 6的同时,还要加上 12 * Math.Pi / 6 / 12.小时刻度里的每一格相当于12</p>
<p>分钟,所以9点12分时,时针要处于9点,并且走过一格的位置.</p>
<h4>分针和秒针</h4>
<p>12分20秒,将画布旋转12 * Math.Pi / 30 和 20 * Math.PI / 30.然后竖直画分针秒针线.(0,0)(0,len)</p>
<p>分和秒的步进都是6度,秒针走60格是1分钟,此时分针走1格,分针走60格是一小时.</p>
<p>分针可以不必像时针那样体现秒针走了多少,例如半分钟时,分针要处在两格子中间.这个不必,当秒针走一圈时,让分针</p>
<p>跳一格就行.</p>
<div class="clockbox">
  <canvas id="canvas1" class="canva-panle"><h3>不支持canvas</h3></canvas>
  <canvas id="canvas2" class="canva-panle"><h3>不支持canvas</h3></canvas>
</div>
<script>
  clockpanel();
  window.requestAnimationFrame(clockAni);
  // 时分秒针行进
  function clockAni() {
    let canvas = document.querySelector('#canvas2');
    ctx = canvas.getContext('2d');
    ctx.canvas.width = 400;
    ctx.canvas.height = 400;
    ctx.clearRect(0, 0, 400, 400);
    //
    let cirxy = { x: 200, y: 200 };
    let cirlen = 160;
    ctx.translate(cirxy.x, cirxy.y);
    //
    let currSec = new Date().getSeconds();
    let currMin = new Date().getMinutes();
    let currHour = new Date().getHours();
    ctx.font = '18px serial';
    ctx.fillText(`${currHour}:${currMin}:${currSec}`,-30, -50);
    // 时针
    ctx.save();
    ctx.rotate(currHour * Math.PI / 6 + currMin * Math.PI / 30/12);
    ctx.beginPath();
    ctx.lineWidth = 4;
    ctx.arc(0, 90 - cirlen, 5, 0, Math.PI * 2);
    ctx.moveTo(0, 12);
    ctx.lineTo(0, 95 - cirlen);
    ctx.stroke();
    ctx.restore();
    // 分针
    ctx.save();
    ctx.strokeStyle = 'orange';
    ctx.rotate(currMin * Math.PI / 30);
    ctx.beginPath();
    ctx.lineWidth = 3;
    ctx.arc(0, 72 - cirlen, 4, 0, Math.PI * 2);
    ctx.moveTo(0, 14);
    ctx.lineTo(0, 76 - cirlen);
    ctx.stroke();
    ctx.restore();
    // 秒针
    ctx.save();
    ctx.strokeStyle = 'red';
    ctx.rotate(currSec * Math.PI / 30);
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.arc(0, 56 - cirlen, 3, 0, Math.PI * 2);
    ctx.moveTo(0, 16);
    ctx.lineTo(0, 60 - cirlen);
    ctx.stroke();
    ctx.restore();
    //
    window.requestAnimationFrame(clockAni);
  }
  // 表盘
  function clockpanel() {
    let canvas = document.querySelector('#canvas1');
    ctx = canvas.getContext('2d');
    ctx.canvas.width = 400;
    ctx.canvas.height = 400;
    //
    let cirxy = { x: 200, y: 200 };// 圆心坐标
    let cirlen = 160;// 圆环大小
    // 圆环(大)
    ctx.save();
    ctx.beginPath();
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#325FA2';
    ctx.arc(cirxy.x, cirxy.y, cirlen, 0, Math.PI * 2);
    ctx.stroke();
    // 圆环(中)
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'gray';
    ctx.arc(cirxy.x, cirxy.y, cirlen*0.74, 0, Math.PI * 2);
    ctx.stroke();
    // 圆环(内)
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.arc(cirxy.x, cirxy.y, cirlen /8, 0, Math.PI * 2);
    ctx.stroke();
    // 圆心
    ctx.beginPath();
    ctx.arc(cirxy.x, cirxy.y, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    // 每30度刻线,小时刻度
    ctx.save();
    ctx.translate(cirxy.x, cirxy.y);
    for (var i = 0; i < 12; i++) {
      ctx.beginPath();
      ctx.moveTo(cirlen - 15, 0);
      ctx.lineTo(cirlen, 0);
      ctx.stroke();
      ctx.rotate(Math.PI / 6);
    }
    ctx.restore();
    // 分钟刻度,每小时分5份,每份6度
    ctx.save();
    ctx.translate(cirxy.x, cirxy.y);
    for (var i = 0; i < 60; i++) {
      if (i % 5 != 0) {
        ctx.beginPath();
        ctx.moveTo(cirlen - 8, 0);
        ctx.lineTo(cirlen, 0);
        ctx.stroke();
      }
      ctx.rotate(Math.PI / 30);
    }
    ctx.restore();
    // 数字
    ctx.save();
    ctx.font = '18px serial';
    ctx.translate(cirxy.x, cirxy.y);
    for (var i = 12; i > 0; i--) {
      ctx.beginPath();
      ctx.fillText(i, -8, 35 - cirlen);
      ctx.rotate(-Math.PI / 6);
    }
    //
    ctx.restore();
  }

</script>
</div></body>
</html>