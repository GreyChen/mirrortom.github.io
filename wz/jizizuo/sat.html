<!DOCTYPE html><html lang=en><head><meta charset=utf-8 /><meta http-equiv=X-UA-Compatible content="IE=edge" /><meta name=viewport content="width=device-width,initial-scale=1.0" /><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png /><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png /><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png /><link rel=manifest href=/site.webmanifest /><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5 /><meta name=msapplication-TileColor content=#da532c /><meta name=theme-color content=#ffffff /><title>分离轴理论 | Mirror Space</title><link href=/mirrorui/mirrorui.css rel=stylesheet /><style scoped>.layout{display:grid;grid-template-columns:210px auto;min-height:100vh}.layout-right{padding:30px}</style></head><body><div class=layout><div class=layout-left><style>.mainmenu{position:sticky;top:122px;text-align:center}.mainmenu a{color:var(--graybackse);text-decoration:none}.mainmenu a:hover,.mainmenu a.active{color:var(--fontcolor);text-decoration:underline}.logobox{width:144px;height:144px;overflow:hidden;border-radius:50%;margin:22px auto}.logoimg{margin-left:-56px;animation:circleRoate 6s infinite linear}@keyframes circleRoate{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}</style><div class=mainmenu><div class=logobox><img src=/asset/img/logo.jpg class=logoimg /></div><h3>Mirror Space</h3><hr class=line /><a href=/index.html><h4>Home</h4></a> <a href=/about.html><h4>About</h4></a> <a href=/projectinfo.html><h4>Info</h4></a></div></div><div class=layout-right><div class=wz-page><div><div id=article_headerbox></div><a onclick=window.history.back() class="btn link danger">返回上页</a><hr class=line /></div><script src=/asset/js/article.js></script><script>(()=>{let f=window.location.pathname,u=f.split("/"),e="article_"+u[2],t=JSON.parse(window.sessionStorage.getItem(e)),i=u[3].replace(".html",""),n={};n.t=t[i][0];n.d=t[i][1];n.a=t[i][2];let r=`<h1 class="text-center">${n.t}</h1>`;r+=`<h5>作者:&emsp;<span></span>${n.a}</h5>`;r+=`<h5>日期:&emsp;<span></span>${n.d}</h5>`;let o=window.document.querySelector("#article_headerbox");o.innerHTML=r})()</script><h2>分离轴定理 Separating Axis Theorem</h2><p>分离轴定理用于判断两个凸多边形是否碰撞.原理的理解如下:</p><p>有两个凸多边形,在一个方向上,用一束光照射,得到两个凸多边形的投影.如果投影有间隙,说明这两个凸多边形没有碰撞.如果没有间隙,可能</p><p>是碰撞的.再换一个方向,用光照射,如果还没有间隙,则可能是碰撞的.再换方向...如此反复,直到所有方向照射的投影都没有间隙,则是碰撞的.</p><p>只要在一个方向上有间隙,就能说明没有碰撞.</p><p>只能用于凸多边形,即内角小于180度的多边形.例如正五边形.五角星不是凸多边形,不适用此法.</p><h3>投影</h3><p>从一个方向,光束照射在凸多边形上,得到的投影.下图假设从上往下,从左往右,两个方向照射,得到的投影用多边形的颜色区分.</p><p>观看投影,发现两个方向的投影都有重叠.可是事实上,这两个物体并没有碰撞.</p><canvas id=canvas1></canvas><p>按照定义,两个物体没有碰撞,那么一定能够找到有间隙的投影.</p><p>下图黄色线就是这个间隙</p><canvas id=canvas2></canvas><h3>轴</h3><p>如上图,阴影所在的线称为"投影轴".如上上图,投影轴就是画布的下边界和右边界.</p><p>这条轴是怎么确定的呢?由图可见,这投影轴并不一定要在图中所示位置,是可以靠前或者靠后,只要与轴平行.其实,投影轴有无数条</p><p>由图可见,投影轴与投射光线垂直.所以,投影轴其实由投射光线决定.</p><h3>投射光线与投影轴</h3><p>那么,投射光线的方向怎么决定?应该说是,从哪个方向做投影.事实上,可以从360度的全部方位进行投影.</p><p>上图就是所有360度方位中的一个方位,此方位的投影找到了间隙,说明了那两个物体没有碰撞.</p><p>SAT定理可以这样看,对于上图的两个物体,拿电灯(点光源)照射,看阴影是否有间隙.将电灯围着两个物体转一圈(360度),如果阴影始终是</p><p>有重叠的,那说明碰撞了.如果在任何一个角度上,阴影有间隙,那就说明没有碰撞.</p><h3>凸多边形的边</h3><p>程序上不用检测360度全方位,只需要检测一些特定的角度就可以.</p><p>凸多边形的每一条边就是一个投射光线的方向.如上图,两个物体一共有7条边,那么只要检测这7个方向就能判断是否碰撞</p><p>而且,只要有一个方向发现阴影有间隙,就说明没有碰撞.剩下的方向就不用检测了</p><h3>检测凸多边形投影</h3><p>实现第一个方法,给定一个多边形,检测它的投影.按边的顺时针方向,求出凸多边形在所有边的投影轴上的投影.</p><p>此方法的关键点是要计算出轴上的阴影位置.每一条轴上有n-1个顶点的投影,投射光线那条边的两个顶点投影重合</p><p>下图按方向 ab - bc - cd - da 分别画出投影轴和投影点</p><canvas id=canvas3></canvas></div><script>function canva3(){var u,n,f;let i=getCanvas2d("canvas3");i.font="16px serial";let t=[90,30,140,40,190,80,65,120];for(drawPolygon(i,t,"gray"),i.fillStyle="red",n=0,u=0;n<t.length;n+=2,u++)i.fillText(String.fromCharCode(65+u),t[n],t[n+1]);let e=getK(t),r=t.concat(t[0],t[1]);for(i.strokeStyle=i.fillStyle="green",n=0,f=0;n<r.length-2;n+=2,f++){let t=r[n],u=r[n+1],f=r[n+2],e=r[n+3];lineArrow(i,[t,u,f,e])}}function canva2(){let n=getCanvas2d("canvas2");n.canvas.width=400;n.canvas.height=200;n.font="16px serial";let t=[100,40,120,120,160,50];drawPolygon(n,t,"blue");let e=[190,90,140,100,190,30,225,40];drawPolygon(n,e,"red");let u=(t[5]-t[3])/(t[4]-t[2]),f=t.concat(e);for(var i=0;i<f.length;i+=2){let t=f[i],r=f[i+1],e=0,o=r+u*(e-t);shadowGuide(n,[t,r,e,o],"gray",1)}let r=-1/u,o=0,s=110,h=200,tt=s+r*(h-o);shadowLine(n,o,s,h,tt,"black",1);let c=0,l=90,a=200,it=l+r*(a-c);shadowLine(n,c,l,a,it,"green",1);let v=45,y=135,p=95,rt=y+r*(p-v);shadowLine(n,v,y,p,rt,"blue",4);let w=102,b=166,k=140,ut=b+r*(k-w);shadowLine(n,w,b,k,ut,"red",4);let d=193,g=0,nt=70,ft=g+u*(nt-d);shadowLine(n,d,g,nt,ft,"gold",4)}function canva1(){let n=getCanvas2d("canvas1"),r=400,u=200;n.canvas.width=r;n.canvas.height=u;n.font="16px serial";let f=[100,40,120,120,160,50];drawPolygon(n,f,"blue");let e=[190,90,140,100,190,30,225,40];drawPolygon(n,e,"red");let t=maxXY(f),i=maxXY(e);n.save();n.setLineDash([5]);lineArrow(n,[0,60,60,60],8);n.fillText("光线",2,80);lineArrow(n,[180,0,180,15],8);n.fillText("光线",185,20);n.restore();shadowLine(n,r-4,t.miny,r-4,t.maxy,"blue",4);shadowLine(n,r-4,i.miny,r-4,i.maxy,"red",4);shadowGuide(n,[0,t.miny,r,t.miny],"blue",1);shadowGuide(n,[0,t.maxy,r,t.maxy],"blue",1);shadowGuide(n,[0,i.miny,r,i.miny],"red",1);shadowGuide(n,[0,i.maxy,r,i.maxy],"red",1);shadowLine(n,t.minx,u-4,t.maxx,u-4,"blue",4);shadowLine(n,i.minx,u-4,i.maxx,u-4,"red",4);shadowGuide(n,[t.minx,0,t.minx,u],"blue",1);shadowGuide(n,[t.maxx,0,t.maxx,u],"blue",1);shadowGuide(n,[i.minx,0,i.minx,u],"red",1);shadowGuide(n,[i.maxx,0,i.maxx,u],"red",1)}function shadowLine(n,t,i,r,u,f,e){n.save();n.beginPath();n.globalAlpha=.5;f&&(n.strokeStyle=f);e&&(n.lineWidth=e);n.moveTo(t,i);n.lineTo(r,u);n.stroke();n.restore()}function shadowGuide(n,t,i,r){n.save();i&&(n.strokeStyle=i);r&&(n.lineWidth=r);n.beginPath();n.setLineDash([5]);n.moveTo(t[0],t[1]);for(var u=2;u<t.length;u+=2)n.lineTo(t[u],t[u+1]);n.stroke();n.restore()}function maxXY(n){let t=n[0],i=n[1],u=t,f=i;for(var r=2;r<n.length;r+=2){let e=n[r];t=Math.max(t,e);u=Math.min(u,e);let o=n[r+1];i=Math.max(i,o);f=Math.min(f,o)}return{maxx:t,maxy:i,minx:u,miny:f}}function drawPolygon(n,t,i){n.save();i&&(n.fillStyle=i);n.beginPath();n.moveTo(t[0],t[1]);for(var r=2;r<t.length;r+=2)n.lineTo(t[r],t[r+1]);n.closePath();n.fill();n.restore()}function getK(n){let i=n.concat(n[0],n[1]),r=[];for(var t=0;t<i.length-2;t+=2){let n=i[t+3]-i[t+1],u=i[t+2]-i[t];if(n==0){r.push(0);continue}if(u==0){r.push(null);continue}r.push(n/u)}return r}function lineArrow(n,t,i=12,r=10,u=true){n.beginPath();n.moveTo(t[0],t[1]);for(var o=2;o<t.length;o+=2)n.lineTo(t[o],t[o+1]);n.stroke();let f={x:t[t.length-2],y:t[t.length-1]},e={x:t[t.length-4],y:t[t.length-3]},s=0;if(f.x==e.x)n.save(),n.translate(f.x,f.y),n.rotate(Math.PI/2),n.beginPath(),s=f.y>e.y?r:-r;else{let t=(f.y-e.y)/(e.x-f.x);n.save();n.translate(f.x,f.y);n.rotate(-Math.atan(t));s=f.x>e.x?r:-r}n.beginPath();n.moveTo(0,-i/2);n.lineTo(0,i/2);n.lineTo(s,0);n.closePath();u==!0?n.fill():n.stroke();n.restore()}function getCanvas2d(n){let t=document.querySelector("#"+n);t.style.display="block";t.style.margin="20px";t.style.backgroundColor="#f0f0f0";return t.getContext("2d")}canva1();canva2();canva3()</script></div></div></body></html>